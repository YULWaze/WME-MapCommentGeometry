Index: WME MapCommentGeometry.user.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// ==UserScript==\n// @name \t\t\tWME MapCommentGeometry\n// @author\t\t\tYUL_\n// @description \tThis script creates a map note around a single selected road segment. It also allows you to create a camera or an arrow shaped note.\n// @match\t\t\t*://*.waze.com/*editor*\n// @exclude\t\t\t*://*.waze.com/user/editor*\n// @grant \t\t\tnone\n// @require\t\t\thttps://greasyfork.org/scripts/24851-wazewrap/code/WazeWrap.js\n// @require\t\t\thttps://davidsl4.github.io/WMEScripts/lib/map-comments-polyfill.js\n// @require\t\t\thttps://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js\n// @downloadURL\t\thttps://raw.githubusercontent.com/YULWaze/WME-MapCommentGeometry/main/WME%20MapCommentGeometry.user.js\n// @updateURL\t\thttps://raw.githubusercontent.com/YULWaze/WME-MapCommentGeometry/main/WME%20MapCommentGeometry.user.js\n// @supportURL\t\thttps://github.com/YULWaze/WME-MapCommentGeometry/issues/new/choose\n// @version \t\t2024.12.28.03\n// ==/UserScript==\n\n/* global W */\n/* global OpenLayers */\n/* ecmaVersion 2017 */\n/* global require */\n/* global $ */\n/* global _ */\n/* global WazeWrap */\n/* eslint curly: [\"warn\", \"multi-or-nest\"] */\n\n// Hacked together by YUL_ based on WME Street to River and WME Wazer Creater\n// Thanks to MapOMatic for fixing WME Wazer Creater\n// Thanks to DeviateFromThePlan for cleaning up the code\n// Thanks to LihtsaltMats for suggesting cleaner placement for the buttons and implementing that\n// Thanks to r0den for allowing the note to be created directly on the segment and cleaning up the code\n\n// Instructions\n// 1) Install this script in Tampermonkey.\n// 2) Select a road in WME (you can create a new one in the shape of the Map Note you want to make).\n// 3) Choose the width of the Map Comment from the dropdown or keep the default.\n// 4) Click the \"Create New\" button at the bottom of the left pane or click the \"Use Existing\" button and then click on an existing Map Note to change its geometry to surround the selected road segment.\n// 5) If you want to convert a point note to a camera or arrow-shaped area, create a new Map Note or select an existing one, and then click the corresponding button.\n// If required, use WME PIE to rotate the resulting shape.\n\n/*\nTo do:\n\n- Clean up and simplify the code\n\n- This will sometimes create map comments with invalid geometry based on how the original road is shaped.\nIt could be interesting to simplify the map comment geometry accordingly.\nSee simplify.js by Volodymyr Agafonkin (https://github.com/mourner/simplify-js)\n\n- Allow this script to place a map comment on multiple selected segments\n\n- Feedback:\n*/\n\n(async function() {\n\tawait SDK_INITIALIZED;\n\tconst UPDATE_NOTES = 'Added ability to create map comment shapes';\n\tconst SCRIPT_NAME = GM_info.script.name;\n\tconst SCRIPT_VERSION = GM_info.script.version;\n\tconst idTitle = 0;\n\tconst idNewMapComment = 1;\n\tconst idExistingMapComment = 2;\n\tconst wmeSdk = getWmeSdk({ scriptId: 'wme-map-comment-geometry', scriptName: 'WME Map Comment Geometry' });\n\n\tconst CameraLeftPoints = [[11,6],[-4,6],[-4,3],[-11,6],[-11,-6],[-4,-3],[-4,-6],[11,-6]];\n\tconst CameraRightPoints = [[-11,6],[4,6],[4,3],[11,6],[11,-6],[4,-3],[4,-6],[-11,-6]];\n\tconst CameraUpPoints = [[6,-11],[6,4],[3,4],[6,11],[-6,11],[-3,4],[-6,4],[-6,-11]];\n\tconst CameraDownPoints = [[6,11],[6,-4],[3,-4],[6,-11],[-6,-11],[-3,-4],[-6,-4],[-6,11]];\n\n    const ArrowRightPoints = [[0,-36],[0,-12],[5,-7],[12,-6],[24,-6],[24,-18],[36,0],[24,18],[24,6],[12,6],[2,4],[-4,2],[-8,-2],[-12,-9],[-12,-36]];\n    const ArrowLeftPoints = [[0,-36],[0,-12],[-5,-7],[-12,-6],[-24,-6],[-24,-18],[-36,0],[-24,18],[-24,6],[-12,6],[-2,4],[4,2],[8,-2],[12,-9],[12,-36]];\n    const ArrowStraightPoints = [[6,-18],[6,6],[18,6],[0,18],[-18,6],[-6,6],[-6,-18]];\n\n\tvar polyPoints = null;\n\tlet prevLeftEq;\n\tlet prevRightEq;\n    let center;\n\n    // Default widths of the Map Comment around the existing road depending on road type\n    // sel.attributes.roadType: 1 = Street, 2 = PS, 3 = Freeway, 4 = Ramp, 6 = MH, 7 = mH, 8 = Offroad, 17 = Private, 20 = Parking lot\n    //\tconst CommentWidths = [15,20,40,15,15,30,30];\n\tconst DefaultCommentWidth = 10;\n\tlet TheCommentWidth;\n\n\tfunction addWMEMCbutton() {\n\t\tif (WazeWrap.hasMapCommentSelected()) {\n\t\t\tlet mapComment = WazeWrap.getSelectedFeatures()[0];\n\t\t\tconst lockRegion = $('.lock-edit-region');\n\n\t\t\tconst regionDiv = $('<div class=\"WME-MC-region\"/>');\n\t\t\tconst mainDiv = $('<div class=\"form-group\"/>');\n\t\t\tconst controlsDiv = $('<div class=\"controls\"/>');\n\n\t\t\tconst createJoystick = (areas, buttons) => {\n\t\t\t\tconst unassignedAreas = new Set(areas.flat());\n\t\t\t\tconst maxControlsInRow = areas.reduce((currentMax, row) => Math.max(currentMax, row.length), 0);\n\t\t\t\tconst cssAreas = areas.map((row) => {\n\t\t\t\t\tif (row.length === maxControlsInRow) return `\"${row.join(' ')}\" 1fr`;\n\n\t\t\t\t\tconst singleAreaUnits = Math.floor(maxControlsInRow / row.length);\n\t\t\t\t\tconst availableUnits = maxControlsInRow - (singleAreaUnits * row.length);\n\n\t\t\t\t\treturn row.reduce((result, currentArea, currentAreaIndex, areas) => {\n\t\t\t\t\t\tconst isLastArea = currentAreaIndex + 1 >= areas.length;\n\t\t\t\t\t\tconst insert = (times) => {\n\t\t\t\t\t\t\tfor (let i = 0; i < times; i++) result.push(currentArea);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinsert(singleAreaUnits);\n\t\t\t\t\t\tif (isLastArea) insert(availableUnits);\n\n\t\t\t\t\t\treturn `\"${result.join(' ')}\" 1fr`;\n\t\t\t\t\t}, []);\n\t\t\t\t}).join(' ');\n\n\t\t\t\tconst joystickContainer = $('<div style=\"display: grid; align-items: center;\"/>');\n\t\t\t\tjoystickContainer.css('grid-template', cssAreas);\n\n\t\t\t\tconst buttonElements = {};\n\t\t\t\tbuttons.forEach((button) => {\n\t\t\t\t\tconst { name, icon, handler, isSelectable = true, flipIconVertically = false } = button;\n\t\t\t\t\tif (!unassignedAreas.has(name)) return;\n\t\t\t\t\tunassignedAreas.delete(name);\n\n\t\t\t\t\tconst $icon = $(`<i class=\"w-icon w-icon-${icon}\" />`);\n\t\t\t\t\tif (flipIconVertically) $icon.css('transform', 'rotateX(180deg)');\n\n\t\t\t\t\tconst $btn = $('<wz-button color=\"clear-icon\" size=\"sm\" />');\n\t\t\t\t\t$btn.css('grid-area', name);\n\t\t\t\t\tif (!isSelectable) {\n\t\t\t\t\t\t$btn.attr('disabled', true);\n\t\t\t\t\t\t$icon.css('color', '#000');\n\t\t\t\t\t}\n\t\t\t\t\t$btn.append($icon);\n\t\t\t\t\t$btn.click((e) => e.target.blur());\n\t\t\t\t\tif (handler) $btn.click(handler);\n\t\t\t\t\tjoystickContainer.append($btn);\n\t\t\t\t\tbuttonElements[name] = $btn;\n\t\t\t\t});\n\n\t\t\t\tArray.from(unassignedAreas.values()).forEach((area) => {\n\t\t\t\t\tconst $dummy = $('<div />');\n\t\t\t\t\t$dummy.css('grid-area', area);\n\t\t\t\t\tjoystickContainer.append($dummy);\n\t\t\t\t})\n\n\t\t\t\treturn {\n\t\t\t\t\troot: joystickContainer,\n\t\t\t\t\tbuttons: buttonElements,\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tconst DPAD_AREA = {\n\t\t\t\tUp: 'up',\n\t\t\t\tLeft: 'left',\n\t\t\t\tRight: 'right',\n\t\t\t\tDown: 'down',\n\t\t\t};\n\t\t\tconst DPAD_NAV_ICONS = {\n\t\t\t\t[DPAD_AREA.Up]: 'arrow-up',\n\t\t\t\t[DPAD_AREA.Down]: 'arrow-down',\n\t\t\t\t[DPAD_AREA.Left]: 'arrow-left',\n\t\t\t\t[DPAD_AREA.Right]: 'arrow-right',\n\t\t\t}\n\t\t\tconst createDPadJoystick = (buttons, dpadIcon, size = '100%') => {\n\t\t\t\tif (buttons.length !== 4) throw new Error('There must be exactly 4 buttons in a D-Pad');\n\n\t\t\t\tbuttons.forEach((button) => {\n\t\t\t\t\tbutton.icon = button.icon || DPAD_NAV_ICONS[button.name];\n\t\t\t\t});\n\n\t\t\t\tconst { root, buttons: buttonElements } = createJoystick([\n\t\t\t\t\t[DPAD_AREA.Up],\n\t\t\t\t\t[DPAD_AREA.Left, 'icon', DPAD_AREA.Right],\n\t\t\t\t\t[DPAD_AREA.Down],\n\t\t\t\t], [\n\t\t\t\t\t...buttons,\n\t\t\t\t\tdpadIcon && { name: 'icon', icon: dpadIcon, isSelectable: false },\n\t\t\t\t].filter(Boolean));\n\n\t\t\t\tObject.entries(buttonElements).forEach(([btnName, $btn]) => {\n\t\t\t\t\tif (!Object.values(DPAD_AREA).includes(btnName)) return;\n\n\t\t\t\t\t$btn.css('justify-self', 'center');\n\t\t\t\t\t$btn.css('width', 'fit-content');\n\t\t\t\t})\n\n\t\t\t\troot.css('aspect-ratio', '1');\n\t\t\t\troot.css('max-width', size);\n\t\t\t\troot.css('background-color', 'var(--surface_default)');\n\t\t\t\troot.css('border-radius', '50%');\n\t\t\t\troot.css('overflow', 'hidden');\n\t\t\t\treturn root;\n\t\t\t}\n\n\t\t\tconst createDPadControl = (controlName, buttons, dpadIcon, size = '100%') => {\n\t\t\t\tconst $container = $('<div style=\"flex: 1\" />');\n\t\t\t\t$container.append($(`<wz-label style=\"text-align: center\">${controlName}</wz-label>`));\n\t\t\t\t$container.append(createDPadJoystick(\n\t\t\t\t\tbuttons,\n\t\t\t\t\tdpadIcon,\n\t\t\t\t\tsize\n\t\t\t\t));\n\t\t\t\treturn $container;\n\t\t\t}\n\n\t\t\tconst joysticksContainers = $('<div class=\"form-group\" style=\"display: flex; gap: 12px\" />');\n\t\t\tjoysticksContainers.append(\n\t\t\t\tcreateDPadControl(\n\t\t\t\t\t'Cameras',\n\t\t\t\t\t[\n\t\t\t\t\t\t{ name: DPAD_AREA.Up, handler: createUCamera },\n\t\t\t\t\t\t{ name: DPAD_AREA.Down, handler: createDCamera },\n\t\t\t\t\t\t{ name: DPAD_AREA.Left, handler: createLCamera },\n\t\t\t\t\t\t{ name: DPAD_AREA.Right, handler: createRCamera },\n\t\t\t\t\t],\n\t\t\t\t\t'speed-camera',\n\t\t\t\t),\n\t\t\t);\n\t\t\tjoysticksContainers.append(\n\t\t\t\tcreateDPadControl(\n\t\t\t\t\t'Arrows',\n\t\t\t\t\t[\n\t\t\t\t\t\t{ name: DPAD_AREA.Up, handler: createSArrow },\n\t\t\t\t\t\t{ name: 'DUMMY', handler: () => null, isSelectable: false, },\n\t\t\t\t\t\t{ name: DPAD_AREA.Left, icon: 'turn-left', handler: createLArrow },\n\t\t\t\t\t\t{ name: DPAD_AREA.Right, icon: 'turn-right', handler: createRArrow },\n\t\t\t\t\t],\n\t\t\t\t),\n\t\t\t);\n\n\t\t\tcontrolsDiv.append(joysticksContainers);\n\n\t\t\tmainDiv.append(controlsDiv);\n\t\t\tregionDiv.append(mainDiv);\n\t\t\tlockRegion.before(regionDiv);\n\t\t}\n\t}\n\n\tasync function createComment(geoJSONGeometry) {\n\t\tlet CO = require(\"Waze/Action/CreateObject\");\n\t\tconst mapComment = await WS.MapNotes.createNote({\n\t\t\tgeoJSONGeometry,\n\t\t});\n\t\tW.model.actionManager.add(new CO(mapComment, W.model.mapComments)); // CO accepts two arguments: entity and repository\n\t\treturn mapComment;\n\t}\n\n\tfunction updateCommentGeometry(geoJSONGeometry, mapComment) {\n\t\tif (!mapComment) {\n\t\t\tif (!WazeWrap.hasMapCommentSelected()) return;\n\t\t\tmapComment = WazeWrap.getSelectedDataModelObjects()[0];\n\t\t}\n\n\t\tlet UO = require(\"Waze/Action/UpdateObject\");\n\t\tW.model.actionManager.add(new UO(mapComment, { geoJSONGeometry }));\n\t}\n\n\tasync function waitForMapCommentSelection() {\n\t\tif (WazeWrap.hasMapCommentSelected())\n\t\t\treturn WazeWrap.getSelectedDataModelObjects()[0];\n\n\t\tawait wmeSdk.Events.once({\n\t\t\teventName: 'wme-selection-changed',\n\t\t});\n\n\t\tif (WazeWrap.hasMapCommentSelected())\n\t\t\treturn WazeWrap.getSelectedDataModelObjects()[0];\n\t\treturn null;\n\t}\n\n\tfunction createLCamera(){ updateCommentGeometry(getShapeWKT(CameraLeftPoints)); }\n\tfunction createUCamera(){ updateCommentGeometry(getShapeWKT(CameraUpPoints)); }\n\tfunction createRCamera(){ updateCommentGeometry(getShapeWKT(CameraRightPoints)); }\n\tfunction createDCamera(){ updateCommentGeometry(getShapeWKT(CameraDownPoints)); }\n\n\tfunction createLArrow(){ updateCommentGeometry(getShapeWKT(ArrowLeftPoints)); }\n    function createSArrow(){ updateCommentGeometry(getShapeWKT(ArrowStraightPoints)); }\n\tfunction createRArrow(){ updateCommentGeometry(getShapeWKT(ArrowRightPoints)); }\n\n\tfunction getShapeWKT(points, center){\n\t\tif (!center) {\n\t\t\tif (!WazeWrap.hasMapCommentSelected()) throw new Error('No map comment selected and no center provided');\n\t\t\tconst mapComment = WazeWrap.getSelectedDataModelObjects()[0];\n\t\t\tcenter = mapComment.getOLGeometry().getCentroid();\n\t\t}\n\n\t\tlet wktText = 'POLYGON((';\n\t\tfor (let i=0; i < points.length; i++){\n\t\t\twktText += `${center.x + points[i][0]} ${center.y + points[i][1]},`;\n\t\t}\n\t\twktText = wktText.slice(0, -1)\n\t\twktText += '))';\n\t\treturn W.userscripts.toGeoJSONGeometry(OpenLayers.Geometry.fromWKT(wktText));\n\t}\n\n\tfunction WMEMapCommentGeometry_bootstrap() {\n\t   var wazeapi = W || window.W;\n\t   if(!wazeapi || !wazeapi.map || !WazeWrap.Interface) {\n\t\t  setTimeout(WMEMapCommentGeometry_bootstrap, 1000);\n\t\t  return;\n\t   }\n\n\t\tWMEMapCommentGeometry_init();\n\t}\n\n\tfunction WMEMapCommentGeometry_init() {\n\t\ttry {\n\t\t\tlet updateMonitor = new WazeWrap.Alerts.ScriptUpdateMonitor(SCRIPT_NAME, SCRIPT_VERSION, 'https://raw.githubusercontent.com/YULWaze/WME-MapCommentGeometry/main/WME%20MapCommentGeometry.user.js', GM_xmlhttpRequest);\n\t\t\tupdateMonitor.start();\n\t\t} catch (ex) {\n\t\t\t// Report, but don't stop if ScriptUpdateMonitor fails.\n\t\t\tconsole.log(ex.message);\n\t\t}\n\n    var langText;\n\n    function addWMESelectSegmentbutton() {\n\n// 2024-03-29 from WME UR-MP tracking\n\t\tconst f = W.selectionManager.getSelectedFeatures()\n\n\t\tif (f.length === 0) {\n\t\t  return null\n\t\t}\n\n\t\t// 2013-04-19: Catch exception\n\t\ttry{\n\t\t\tif(document.getElementById('MapCommentGeo') !== null) return;\n\t\t}\n\t\tcatch(e) { }\n\n\t\t// Add button\n\t\tconst createMapNoteBtn = $(`<wz-button style=\"--space-button-text: 100%;\" size=\"sm\" color=\"text\">${getString(idNewMapComment)}</wz-button>`);\n\t\tcreateMapNoteBtn.click((e) => {\n\t\t\te.target.blur();\n\t\t\tcreateComment(getGeometryOfSelection()).then((mapComment) => {\n\t\t\t\tW.selectionManager.unselectAll();\n\t\t\t\tW.selectionManager.selectFeatures([mapComment.getID()]);\n\t\t\t});\n\t\t});\n\n\t\tconst useMapNoteBtn = $(`<wz-button style=\"--space-button-text: 100%;\" size=\"sm\" color=\"text\">${getString(idExistingMapComment)}</wz-button>`);\n\t\tuseMapNoteBtn.click(async (e) => {\n\t\t\te.target.blur();\n\t\t\te.target.disabled = true;\n\t\t\tconst selectionGeometry = getGeometryOfSelection();\n\t\t\tWazeWrap.Alerts.info('WME Map Comment Geometry', 'Select an existing map comment to update its geometry');\n\t\t\tconst mapComment = await waitForMapCommentSelection();\n\t\t\tuseMapNoteBtn.disabled = false;\n\t\t\tif (!mapComment) return;\n\t\t\tupdateCommentGeometry(selectionGeometry, mapComment);\n\t\t});\n\n\t\t// Add dropdown for comment width\n\t\tconst selCommentWidth = $('<wz-select id=\"CommentWidth\" style=\"flex: 1\" />');\n\t\tselCommentWidth.append( $('<wz-option value=\"5\">5 m</wz-option>') );\n\t\tselCommentWidth.append( $('<wz-option value=\"10\">10 m</wz-option>') );\n\t\tselCommentWidth.append( $('<wz-option value=\"15\">15 m</wz-option>') );\n\t\tselCommentWidth.append( $('<wz-option value=\"20\">20 m</wz-option>') );\n\t\tselCommentWidth.append( $('<wz-option value=\"25\">25 m</wz-option>') );\n\t\tselCommentWidth.attr('value', getLastCommentWidth(DefaultCommentWidth));\n\t\tconst selCommentWidthStyles = new CSSStyleSheet();\n\t\tselCommentWidthStyles.replaceSync('.wz-select { min-width: initial !important }');\n\t\tselCommentWidth[0].shadowRoot.adoptedStyleSheets.push(selCommentWidthStyles);\n\n\t\t// Add MapCommentGeo section\n\t\tconst rootContainer = $('<section id=\"MapCommentGeo\" />');\n\t\trootContainer.append($('<div class=\"form-group\" />')); // add an empty form group just for the margin above\n\n\t\t// Add comment width to section\n\t\tconst mapNoteWidthContainer = $('<div class=\"form-group\" />');\n\t\tmapNoteWidthContainer.append( $('<wz-label>Map Note Width</wz-label>') );\n\t\tconst mapNoteWidthControls = $('<div style=\"display: flex; gap: 12px;\" />');\n\t\tmapNoteWidthControls.append(selCommentWidth);\n\t\tmapNoteWidthControls.append(createMapNoteBtn, useMapNoteBtn);\n\t\tmapNoteWidthContainer.append(mapNoteWidthControls);\n\t\trootContainer.append(mapNoteWidthContainer);\n\n\t\t$(\"#segment-edit-general\").append(rootContainer);\n\n\t\tWazeWrap.Interface.ShowScriptUpdate(SCRIPT_NAME, SCRIPT_VERSION, UPDATE_NOTES, '');\n\n\t\tconsole.log(\"WME MapCommentGeometry\");\n\t}\n\n\tfunction getSegmentsPath(segmentIds, getSegment, getConnectedSegments) {\n\t\tconst visitedSegments = new Set();\n\t\tconst forwardResult = [], backwardResult = [];\n\n\t\t// Convert segmentIds to a Set for quick lookup\n\t\tconst validSegmentIds = new Set(segmentIds);\n\n\t\t// Start traversal from the first segment in the list\n\t\tconst initialSegmentId = segmentIds[0];\n\t\tconst { fromNodeId, toNodeId } = getSegment(initialSegmentId);\n\n\t\t// Queues for forward and backward traversal\n\t\tconst forwardQueue = [];\n\t\tconst backwardQueue = [];\n\n\t\tconst addToQueue = (queue, nextNodeId) => {\n\t\t\tconst connectedSegments = getConnectedSegments(nextNodeId);\n\t\t\tfor (const connectedSegment of connectedSegments) {\n\t\t\t\tif (!validSegmentIds.has(connectedSegment) || visitedSegments.has(connectedSegment)) continue;\n\t\t\t\tqueue.push({ segmentId: connectedSegment, currentNodeId: nextNodeId });\n\t\t\t}\n\t\t}\n\n\t\tforwardResult.push({ segmentId: initialSegmentId, direction: 'fwd' });\n\t\tvisitedSegments.add(initialSegmentId);\n\t\taddToQueue(forwardQueue, toNodeId);\n\t\taddToQueue(backwardQueue, fromNodeId);\n\n\t\twhile (forwardQueue.length > 0) {\n\t\t\tconst { segmentId, currentNodeId } = forwardQueue.shift();\n\n\t\t\tif (visitedSegments.has(segmentId)) continue;\n\t\t\tvisitedSegments.add(segmentId);\n\n\t\t\t// Query segment details\n\t\t\tconst { fromNodeId, toNodeId } = getSegment(segmentId);\n\n\t\t\t// Determine the segment's direction\n\t\t\tconst direction = currentNodeId === fromNodeId ? \"fwd\" : \"rev\";\n\t\t\tforwardResult.push({ segmentId, direction });\n\n\t\t\t// Get the next node to traverse\n\t\t\tconst nextNodeId = direction === 'fwd' ? toNodeId : fromNodeId;\n\t\t\taddToQueue(forwardQueue, nextNodeId);\n\t\t}\n\n\t\twhile (backwardQueue.length > 0) {\n\t\t\tconst { segmentId, currentNodeId } = backwardQueue.shift();\n\n\t\t\tif (visitedSegments.has(segmentId)) continue;\n\t\t\tvisitedSegments.add(segmentId);\n\n\t\t\t// Query segment details\n\t\t\tconst { fromNodeId, toNodeId } = getSegment(segmentId);\n\n\t\t\t// Determine the segment's direction\n\t\t\tconst direction = currentNodeId === fromNodeId ? \"rev\" : \"fwd\";\n\t\t\tbackwardResult.push({ segmentId, direction });\n\n\t\t\t// Get the next node to traverse\n\t\t\tconst nextNodeId = direction === 'fwd' ? fromNodeId : toNodeId;\n\t\t\taddToQueue(backwardQueue, nextNodeId);\n\t\t}\n\n\t\treturn [...backwardResult.reverse(), ...forwardResult];\n\t}\n\n\tfunction mergeSegmentsGeometry(segmentIds) {\n\t\tconst segmentsPath = getSegmentsPath(\n\t\t\tsegmentIds,\n\t\t\t(segmentId) => wmeSdk.DataModel.Segments.getById({ segmentId }),\n\t\t\t(nodeId) => wmeSdk.DataModel.Nodes.getById({ nodeId }).connectedSegmentIds,\n\t\t);\n\n\t\treturn segmentsPath.reduce((points, { segmentId, direction }) => {\n\t\t\tconst segment = wmeSdk.DataModel.Segments.getById({ segmentId });\n\t\t\tconst segmentGeometry = segment.geometry.coordinates;\n\t\t\tif (direction === 'rev') segmentGeometry.reverse();\n\n\t\t\t// Remove the last point of the previous segment to avoid duplicate points\n\t\t\tif (points.length > 0) points.pop();\n\t\t\treturn points.concat(segmentGeometry);\n\t\t}, []);\n\t}\n\n\tfunction getGeometryForSegments(segments, width) {\n\t\tconst conversion = {\n\t\t\tpoints: null,\n\t\t\tlastLeftEq: null,\n\t\t\tlastRightEq: null,\n\t\t};\n\n\t\tconst mergedGeometryCoordinates = mergeSegmentsGeometry(segments.map((segment) => segment.attributes.id));\n\t\tconst mergedGeoJSONGeometry = {\n\t\t\ttype: 'LineString',\n\t\t\tcoordinates: mergedGeometryCoordinates,\n\t\t};\n\n\t\treturn convertToLandmark(mergedGeoJSONGeometry, NaN, 0, conversion, width);\n\t}\n\n\tfunction getGeometryOfSelection(width) {\n\t\tif (!width) {\n\t\t\tconst selCommentWidth = document.getElementById('CommentWidth');\n\t\t\twidth = parseInt(selCommentWidth.value, 10);\n\t\t\tsetlastCommentWidth(width);\n\t\t}\n\n\t\tconsole.log(`Comment width: ${width}`);\n\n\t\tconst selectedFeatures = W.selectionManager.getSelectedFeatures();\n\t\tif (selectedFeatures.length === 0) {\n\t\t\tconsole.error('No road selected!');\n\t\t\treturn null;\n\t\t}\n\n\t\tconst segments = selectedFeatures\n\t\t\t.map((feature) => feature._wmeObject)\n\t\t\t.filter((object) => object.type === 'segment');\n\n\t\treturn getGeometryForSegments(segments, width);\n\t}\n\n\t// Based on selected helper road modifies a map comment to precisely follow the road's geometry\n\tfunction convertToLandmark(geometry, NumSegments, s, conversion = { points: polyPoints, lastRightEq: prevRightEq, lastLeftEq: prevLeftEq }, width = TheCommentWidth) {\n\t\tlet i;\n\t\tlet leftPa; let rightPa; let leftPb; let rightPb;\n\n\t\tconst olGeometry = W.userscripts.toOLGeometry(geometry);\n\t\tconst streetVertices = olGeometry.getVertices();\n\n\t\tconst firstStreetVerticeOutside = 0;\n\n\t\t// 2013-10-13: Add to polyPoints polygon\n\t\tif (s<=1) {\n\t\t\tconsole.log('WME Map Comment polygon: Create');\n\t\t}\n\t\tconst first = 0;\n\n//\t\tpolyPoints = null;\n\n\t\tfor (i = first; i < streetVertices.length - 1; i++) {\n\t\t\tconst pa = streetVertices[i];\n\t\t\tconst pb = streetVertices[i + 1];\n\t\t\tconst scale = (pa.distanceTo(pb) + width) / pa.distanceTo(pb);\n\t\t\tleftPa = pa.clone();\n\t\t\tleftPa.resize(scale, pb, 1);\n\t\t\trightPa = leftPa.clone();\n\t\t\tleftPa.rotate(90, pa);\n\t\t\trightPa.rotate(-90, pa);\n\n\t\t\tleftPb = pb.clone();\n\t\t\tleftPb.resize(scale, pa, 1);\n\t\t\trightPb = leftPb.clone();\n\t\t\tleftPb.rotate(-90, pb);\n\t\t\trightPb.rotate(90, pb);\n\n\t\t\tconst leftEq = getEquation({\n\t\t\t\tx1: leftPa.x, y1: leftPa.y, x2: leftPb.x, y2: leftPb.y\n\t\t\t});\n\t\t\tconst rightEq = getEquation({\n\t\t\t\tx1: rightPa.x, y1: rightPa.y, x2: rightPb.x, y2: rightPb.y\n\t\t\t});\n\n\t\t\tif (conversion.points === null) conversion.points = [leftPa, rightPa];\n\t\t\telse {\n\t\t\t\tconst li = intersectX(leftEq, conversion.lastLeftEq);\n\t\t\t\tconst ri = intersectX(rightEq, conversion.lastRightEq);\n\t\t\t\tif (li && ri) {\n\t\t\t\t\t// 2013-10-17: Is point outside comment?\n\t\t\t\t\tif (i >= firstStreetVerticeOutside) {\n\t\t\t\t\t\tconversion.points.unshift(li);\n\t\t\t\t\t\tconversion.points.push(ri);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// 2013-10-17: Is point outside comment?\n\t\t\t\t\tif (i >= firstStreetVerticeOutside) {\n\t\t\t\t\t\tconversion.points.unshift(leftPb.clone());\n\t\t\t\t\t\tconversion.points.push(rightPb.clone());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconversion.lastLeftEq = leftEq;\n\t\t\tconversion.lastRightEq = rightEq;\n\n\t\t\tconsole.log(`Point:${leftPb}  ${rightPb}`);\n\t\t}\n\n\t\tconversion.points.push(rightPb);\n\t\tconversion.points.push(leftPb);\n\n\t\t// YUL_: Add the first point at the end of the array to close the shape!\n\t\t// YUL_: When creating a comment or other polygon, WME will automatically do this, but since we are modifying an existing Map Comment, we must do it here!\n\t\tif (s==0) {\n\t\t\tconversion.points.push(conversion.points[0]);\n\t\t\t// YUL_: At this point we have the shape we need, and have to convert the existing map comment into that shape.\n\t\t\tconsole.log(\"WME Map Comment polygon: done\");\n\t\t}\n\n\t\tconst polygon = new OpenLayers.Geometry.Polygon(\n\t\t\tnew OpenLayers.Geometry.LinearRing(conversion.points),\n\t\t);\n\t\treturn W.userscripts.toGeoJSONGeometry(polygon);\n  }\n\n\tfunction getEquation(segment) {\n\t\tif (segment.x2 == segment.x1) {\n\t\t\treturn { 'x': segment.x1 };\n\t\t}\n\n\t\tvar slope = (segment.y2 - segment.y1) / (segment.x2 - segment.x1);\n\t\tvar offset = segment.y1 - (slope * segment.x1);\n\t\treturn { 'slope': slope, 'offset': offset };\n\t}\n\n\t// line A: y = ax + b\n\t// line B: y = cx + b\n\t// x = (d - b) / (a - c)\n\tfunction intersectX(eqa,eqb,defaultPoint) {\n\t\tif (\"number\" == typeof eqa.slope && \"number\" == typeof eqb.slope) {\n\t\t\tif (eqa.slope == eqb.slope) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar ix = (eqb.offset - eqa.offset) / (eqa.slope - eqb.slope);\n\t\t\tvar iy = eqa.slope * ix + eqa.offset;\n\t\t\treturn new OpenLayers.Geometry.Point(ix, iy);\n\t\t}\n\t\telse if (\"number\" == typeof eqa.x) {\n\t\t\treturn new OpenLayers.Geometry.Point(eqa.x, eqb.slope * eqa.x + eqb.offset);\n\t\t}\n\t\telse if (\"number\" == typeof eqb.y) {\n\t\t\treturn new OpenLayers.Geometry.Point(eqb.x, eqa.slope * eqb.x + eqa.offset);\n\t\t}\n\t\treturn null;\n\t}\n\n\tfunction getStreet(segment) {\n\t\tif (!segment.attributes.primaryStreetID) {\n\t\t\treturn null;\n\t\t}\n\t\tvar street = segment.model.streets.get(segment.attributes.primaryStreetID);\n\t\treturn street;\n\t}\n\n\t// 2013-06-09: Save current comment Width\n\tfunction setlastCommentWidth(CommentWidth){\n\t\tif(typeof(Storage)!==\"undefined\"){\n\t\t\t// 2013-06-09: Yes! localStorage and sessionStorage support!\n\t\t\tsessionStorage.CommentWidth=Number(CommentWidth);\n\t\t }\n\t\t else{\n\t\t   // Sorry! No web storage support..\n\t\t   console.log(\"No web storage support\");\n\t\t }\n\t}\n\n\t// 2013-06-09: Returns last saved comment width\n\tfunction getLastCommentWidth(CommentWidth){\n\t\tif(typeof(Storage)!==\"undefined\"){\n\t\t\t// 2013-06-09: Yes! localStorage and sessionStorage support!\n\t\t\tif(sessionStorage.CommentWidth)\n\t\t\t\treturn Number(sessionStorage.CommentWidth);\n\t\t\telse\n\t\t\t\treturn Number(CommentWidth);\t// Default comment width\n\t\t }\n\t\t else{\n\t\t   return Number(CommentWidth);\t// Default comment width\n\t\t }\n\t}\n\n\t// 2014-06-05: Returns WME interface language\n\tfunction getLanguage() {\n\t\tvar wmeLanguage;\n\t\tvar urlParts;\n\t\turlParts = location.pathname.split(\"/\");\n\t\twmeLanguage = urlParts[1].toLowerCase();\n\t\tif (wmeLanguage===\"editor\") {\n\t\t\twmeLanguage = \"us\";\n\t\t}\n\t\treturn wmeLanguage;\n\t}\n\n\t// 2014-06-05: Translate text to different languages\n\tfunction intLanguageStrings() {\n\t\tswitch(getLanguage()) {\n\t\t\tdefault:\t\t// 2014-06-05: English\n\t\t\t\tlangText = new Array(\"Select a road and click this button.\",\"Create New\", \"Use Existing\");\n\t\t}\n\t}\n\n\t// 2014-06-05: Returns the translated string to current language, if the language is not recognized assumes English\n\tfunction getString(stringID) {\n\t\treturn langText[stringID];\n\t}\n\n\tintLanguageStrings();\n\n\tW.selectionManager.events.register(\"selectionchanged\", null, addWMESelectSegmentbutton);\n\tW.selectionManager.events.register(\"selectionchanged\", null, addWMEMCbutton);\n}\n\nWMEMapCommentGeometry_bootstrap();\n\n})();\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/WME MapCommentGeometry.user.js b/WME MapCommentGeometry.user.js
--- a/WME MapCommentGeometry.user.js	(revision e3b3e68c58444c891872b46eaf69d1e8a02c829c)
+++ b/WME MapCommentGeometry.user.js	(date 1735408924644)
@@ -268,6 +268,41 @@
 		return null;
 	}
 
+	function convertLineToArrow(line) {
+		const lastPoint = line[line.length - 1];
+		const secondLastPoint = line[line.length - 2];
+		const angle = Math.atan2(lastPoint[1] - secondLastPoint[1], lastPoint[0] - secondLastPoint[0]);
+
+		const arrowSize = 20; // Arrow size in meters
+		const leftWing = turf.destination(
+			turf.point(lastPoint),
+			arrowSize,
+			angle + Math.PI / 6,
+			{ units: 'meters' },
+		);
+		const rightWing = turf.destination(
+			turf.point(lastPoint),
+			arrowSize,
+			angle - Math.PI / 6,
+			{ units: 'meters' },
+		);
+
+		const surroundedLine = turf.buffer(
+			line,
+			arrowSize / 3,
+			{ units: 'meters' },
+		);
+
+		return turf.union(
+			surroundedLine,
+			turf.polygon([[
+				leftWing.geometry.coordinates,
+				rightWing.geometry.coordinates,
+				lastPoint,
+			]]),
+		);
+	}
+
 	function createLCamera(){ updateCommentGeometry(getShapeWKT(CameraLeftPoints)); }
 	function createUCamera(){ updateCommentGeometry(getShapeWKT(CameraUpPoints)); }
 	function createRCamera(){ updateCommentGeometry(getShapeWKT(CameraRightPoints)); }
